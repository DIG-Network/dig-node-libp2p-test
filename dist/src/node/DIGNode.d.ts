import type { Libp2p } from 'libp2p';
import { DIGNodeConfig, NodeCapabilities } from './types.js';
export declare class DIGNode {
    private config;
    private node;
    private digFiles;
    private digPath;
    private cryptoIPv6;
    private watcher;
    private syncInterval;
    private discoveredPeers;
    private peerStores;
    private syncInProgress;
    private isStarted;
    private logger;
    private startTime;
    private globalDiscovery;
    private webSocketRelay;
    private e2eEncryption;
    private zkPrivacy;
    private peerProtocolVersions;
    private nodeCapabilities;
    private requestCounts;
    private app;
    private httpServer;
    private io;
    private registeredPeers;
    private relayConnections;
    private turnServers;
    private cleanupInterval;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly PEER_TIMEOUT;
    private privacyOverlayPeers;
    private gossipTopics;
    private metrics;
    constructor(config?: DIGNodeConfig);
    private ensureDigDirectory;
    private detectEnvironment;
    private safeServiceInit;
    getCapabilities(): NodeCapabilities;
    private addOptionalService;
    private getBootstrapServerHost;
    private createCircuitRelayAddress;
    start(): Promise<void>;
    stop(): Promise<void>;
    private cleanup;
    private validateConfig;
    private validateStoreId;
    private sanitizeFilePath;
    getMetrics(): any;
    getStatus(): any;
    private setupBuiltInBootstrapServer;
    private startBuiltInBootstrapServer;
    private getBootstrapPort;
    private resolveCryptoIPv6Address;
    private enforceEncryptionPolicy;
    private validateMandatoryEncryption;
    private rejectUnencryptedConnection;
    private verifyOutgoingEncryption;
    private createHandshakeInfo;
    private getNodeTypeDescription;
    private getNodeTypeFromCode;
    private startDistributedPrivacyDiscovery;
    private handleGossipMessage;
    private handlePeerDiscoveryGossip;
    private handleAddressExchangeGossip;
    private handleStoreAnnouncementGossip;
    private handleCapabilityAnnouncementGossip;
    private announceToPrivacyOverlay;
    private storeAddressInDHT;
    private resolveDistributedPeerAddresses;
    private handlePeerExchangeRequest;
    private handlePrivacyPeerDiscoveryRequest;
    requestPeersFromNode(peerId: string, privacyMode?: boolean): Promise<any[]>;
    getPrivacyTurnServers(): Array<{
        peerId: string;
        cryptoIPv6: string;
        capabilities: NodeCapabilities;
    }>;
    getPrivacyBootstrapServers(): Array<{
        peerId: string;
        cryptoIPv6: string;
        capabilities: NodeCapabilities;
    }>;
    discoverPeersFromAllSources(): Promise<void>;
    private pullPeersFromBootstrap;
    private discoverPeersFromNetwork;
    private inferCapabilitiesFromPeer;
    downloadStoreWithFullFallback(storeId: string): Promise<boolean>;
    private downloadStoreFromDHT;
    private downloadStoreFromGossipNetwork;
    private downloadStoreFromDistributedTurn;
    private downloadStoreViaMeshRouting;
    private downloadStoreViaBootstrapTurn;
    private downloadStoreFromSpecificPeer;
    private queryPeerForStore;
    private downloadStoreViaPeerTurn;
    private downloadStoreViaRoute;
    private requestStoreRoute;
    private isSelfRelay;
    private handleProtocolHandshake;
    private checkTurnCapability;
    private initiateProtocolHandshake;
    private scanDIGFiles;
    private loadDIGFile;
    private isRateLimited;
    private handleDIGRequest;
    private serveFileFromURN;
    private serveFileRange;
    private serveFileFromStore;
    private handleDiscoveryRequest;
    private announceStores;
    private announceStore;
    getAvailableStores(): string[];
    hasStore(storeId: string): boolean;
    getCryptoIPv6(): string;
    getNode(): Libp2p;
    rescanDIGFiles(): Promise<void>;
    isHealthy(): boolean;
    getNetworkHealth(): any;
    findStorePeers(storeId: string): Promise<any[]>;
    private startFileWatcher;
    private runFileWatcher;
    private handleFileSystemEvent;
    private addOrUpdateStore;
    private removeStore;
    private startPeerDiscovery;
    private startStoreSync;
    private discoverPeerStores;
    private syncStores;
    private downloadStoreFromPeers;
    private downloadStoreInParallelFromPeers;
    private downloadChunkFromLibP2PPeer;
    private executeConcurrentDownloads;
    private collectChunkResponse;
    private assembleChunks;
    private getFileSizeFromPeer;
    private saveDownloadedStore;
    private downloadStoreFromLibP2PPeer;
    private downloadStoreViaTurnServers;
    private startGlobalDiscovery;
    private startWebSocketRelay;
    private detectTurnCapability;
    private registerAsTurnServer;
    private connectToDiscoveredPeers;
    private connectToConfiguredPeers;
    connectToPeer(peerAddress: string): Promise<void>;
    getConnectionInfo(): any;
    forceConnectToPeers(): Promise<void>;
    private connectViaRelay;
    private initiateRelayConnection;
    private handleRelayOffer;
    private discoverPeerStoresViaRelay;
    private downloadStoreViaRelay;
    private syncStoresViaBootstrap;
    private downloadStoreViaBootstrap;
    discoverAllPeers(): Promise<void>;
}
